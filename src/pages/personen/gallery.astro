---
import BaseLayout from "../../layouts/BaseLayout.astro";
import rawDescriptorsById from "../../assets/personen/descriptors.byId.json";

export const chronik = {
  title: "Gesichter von Pechgrün",
  subtitle: "Fotografien von Menschen, die dort gelebt haben",
  date: "2026-01-05",
  bereich: "Personen",
  href: "/personen/gallery",
  order: 2,
};

const PORTRAIT_H = 520; // fixe Höhe nur Portrait

const descriptorsById = rawDescriptorsById as Record<string, string>;

type UrlMods = Record<string, string>;

const fullMods = import.meta.glob("/src/assets/personen/*-full.jpg", {
  eager: true,
  query: "?url",
  import: "default",
}) as UrlMods;

const smallMods = import.meta.glob("/src/assets/personen/small/*-small.jpg", {
  eager: true,
  query: "?url",
  import: "default",
}) as UrlMods;

function buildUrlMap(mods: UrlMods): Map<string, string> {
  const map = new Map<string, string>();
  for (const [path, url] of Object.entries(mods)) {
    const file = path.split("/").pop() ?? "";
    const id = file.replace("-small.jpg", "").replace("-full.jpg", "");
    map.set(id, url);
  }
  return map;
}

const fullMap = buildUrlMap(fullMods);
const smallMap = buildUrlMap(smallMods);

// IDs dynamisch bestimmen (damit 2 Bilder sofort funktionieren)
const order: string[] = Array.from(
  new Set([...smallMap.keys()].filter((id) => fullMap.has(id)))
).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

type Item = {
  id: string;
  small: string;
  full: string;
  title: string;
  desc: string;
};

const items: Item[] = order.map((id) => ({
  id,
  small: smallMap.get(id)!,
  full: fullMap.get(id)!,
  title: id.toUpperCase(),
  desc: typeof descriptorsById[id] === "string" ? descriptorsById[id] : "",
}));

const splitLines = (s: string) => String(s || "").split(/\r?\n/);

// fixed thumb size (square)
const THUMB_SIZE = 74;
---

<BaseLayout title={chronik.title}>
  <article class="page">
    <header class="head">
      <h1>{chronik.title}</h1>
      <p class="subtitle">{chronik.subtitle}</p>
    </header>

<section class="intro">
  <p>
    Diese Galerie zeigt Gesichter von Menschen, die einst in Pechgrün gelebt
    haben. Viele von ihnen sind heute nicht mehr am Leben; fast alle wurden nach
    dem Zweiten Weltkrieg aus ihrer Heimat vertrieben und gezwungen, den Ort zu
    verlassen. Was von ihnen geblieben ist, sind wenige Fotografien, Namen in
    Dokumenten und Erinnerungen, die sich nur bruchstückhaft erhalten haben.
  </p>

  <p>
    Die Bilder sind keine vollständige Chronik und kein geschlossenes Porträt
    einer Dorfgemeinschaft. Sie zeigen einzelne Menschen, oft ohne genaue
    Datierung, manchmal ohne sichere Identifikation. Dennoch geben sie einen
    Eindruck von den Gesichtern, die zu Pechgrün gehörten – von denen, die dort
    aufwuchsen, arbeiteten, Familien gründeten und ihr Leben verbrachten.
  </p>

  <p>
    Die Bildunterschriften enthalten alles, was zu den einzelnen Fotografien
    bekannt ist. Sie dienen zugleich als Suchgrundlage: Über das Eingabefeld
    lassen sich Namen oder andere Textfragmente finden, sofern sie in den
    Beschreibungen vorkommen.
  </p>

  <p class="hint">
    Tipp: Mit den Pfeiltasten ← / → wechseln oder über die Thumbnails oben direkt
    springen.
  </p>
</section>

    {items.length === 0 ? (
      <p>
        Keine Bilder gefunden. Prüfe bitte <code>src/assets/personen/</code>.
      </p>
    ) : (
      <section class="viewer viewer-wrap" data-gallery>
        <script is:inline define:vars={{ items, PORTRAIT_H }}>
          (() => {
            let pendingDelta = 0;
            let initialized = false;

            const onKeyDownEarly = (e) => {
              if (e.metaKey || e.ctrlKey || e.altKey) return;

              // If an input/textarea/contenteditable has focus, do NOT hijack arrow keys.
              const ae = document.activeElement;
              if (
                ae &&
                (ae.tagName === "INPUT" ||
                  ae.tagName === "TEXTAREA" ||
                  ae.isContentEditable)
              ) {
                return;
              }

              if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;

              e.preventDefault();
              if (!initialized) pendingDelta += e.key === "ArrowRight" ? 1 : -1;
            };

            window.addEventListener("keydown", onKeyDownEarly, { passive: false });

            const waitForReady = () => {
              const root = document.querySelector("[data-gallery]");
              if (!root) return requestAnimationFrame(waitForReady);

              const heroFrame = root.querySelector("[data-hero-frame]");
              const heroImg = root.querySelector("[data-hero-img]");
              const caption = root.querySelector("[data-caption]");
              const thumbs = Array.from(root.querySelectorAll("[data-thumb]"));
              const stripScroll = root.querySelector(".strip-scroll");
              const strip = root.querySelector("[data-strip]");
              const indicator = root.querySelector("[data-thumb-indicator]");
              const openFullBtn = root.querySelector("[data-open-full]");
              const filterInput = root.querySelector("#personFilter");
              const hitCountEl = root.querySelector("[data-hit-count]");

              if (
                !(heroFrame instanceof HTMLElement) ||
                !(heroImg instanceof HTMLImageElement) ||
                !(caption instanceof HTMLElement) ||
                !(stripScroll instanceof HTMLElement) ||
                !(strip instanceof HTMLElement) ||
                !(indicator instanceof HTMLElement) ||
                thumbs.length === 0
              ) {
                return requestAnimationFrame(waitForReady);
              }

              const NO_HITS_TEXT = "Keine Treffer für diesen Filter.";

              let index = 0;
              let filtered = items.map((_, i) => i);

              // NBSP-safe normalize + search-normalization (case + umlaut tolerant)
              const normalizeSearch = (s) => {
                let x = String(s ?? "").replace(/\u00A0/g, " ").toLowerCase().trim();
                // German search tolerance
                x = x
                  .replace(/ß/g, "ss")
                  .replace(/ä/g, "ae")
                  .replace(/ö/g, "oe")
                  .replace(/ü/g, "ue");
                return x;
              };

              const clampInFiltered = (pos) => {
                const n = filtered.length;
                if (n <= 0) return 0;
                return (pos + n) % n;
              };

              const renderCaption = (text) => {
                caption.innerHTML = "";
                if (!text) return;
                String(text)
                  .split(/\r?\n/)
                  .forEach((line, i) => {
                    if (i > 0) caption.appendChild(document.createElement("br"));
                    caption.appendChild(document.createTextNode(line));
                  });
              };

              const applyOrientationFor = (src) => {
                const probe = new Image();
                probe.onload = () => {
                  const portrait = probe.naturalHeight > probe.naturalWidth;
                  heroFrame.classList.toggle("is-portrait", portrait);
                  heroFrame.classList.toggle("is-landscape", !portrait);
                };
                probe.src = src;
              };

              const openFullInNewTab = () => {
                const it = items[index];
                if (!it?.full) return;
                window.open(it.full, "_blank", "noopener");
              };

              const centerThumb = (btn) => {
                const s = stripScroll.getBoundingClientRect();
                const b = btn.getBoundingClientRect();
                const btnCenter = b.left - s.left + b.width / 2;
                const target =
                  stripScroll.scrollLeft + btnCenter - stripScroll.clientWidth / 2;
                stripScroll.scrollTo({ left: target, behavior: "auto" });
              };

              const moveIndicatorTo = (i) => {
                const btn = thumbs[i];
                if (!(btn instanceof HTMLElement)) return;

                indicator.style.opacity = "1";
                indicator.style.transform = `translate(${btn.offsetLeft}px, ${btn.offsetTop}px)`;
                indicator.style.width = `${btn.offsetWidth}px`;
                indicator.style.height = `${btn.offsetHeight}px`;
              };

              const setActiveThumb = (i, wrapped = false) => {
                thumbs.forEach((t, k) => t.classList.toggle("is-active", k === i));
                moveIndicatorTo(i);

                const firstIndex = filtered.length ? filtered[0] : 0;
                const lastIndex = filtered.length ? filtered[filtered.length - 1] : 0;

                if (wrapped) {
                  stripScroll.scrollLeft = i === firstIndex ? 0 : stripScroll.scrollWidth;
                  return;
                }

                if (i === firstIndex) {
                  stripScroll.scrollLeft = 0;
                  return;
                }

                if (i === lastIndex) {
                  stripScroll.scrollLeft = stripScroll.scrollWidth;
                  return;
                }

                const btn = thumbs[i];
                if (btn instanceof HTMLElement) centerThumb(btn);
              };

              const render = (i, wrapped = false) => {
                const it = items[i];
                if (!it) return;
                index = i;

                heroFrame.style.display = "";

                applyOrientationFor(it.full);
                heroImg.src = it.full;
                heroImg.alt = it.title;

                renderCaption(it.desc);
                setActiveThumb(i, wrapped);
              };

              thumbs.forEach((btn) =>
                btn.addEventListener("click", () => {
                  const i = Number(btn.dataset.index);
                  if (!filtered.includes(i)) return;
                  render(i);
                })
              );

              openFullBtn?.addEventListener("click", openFullInNewTab);

              // Parse query into OR-groups (comma) of AND-terms (spaces),
              // while allowing "exact phrases" using quotes or [brackets].
              const parseQuery = (qRaw) => {
                const raw = String(qRaw ?? "");

                // collect phrases in original form; placeholders survive normalization
                const phrases = [];

                const addPhrase = (txt) => {
                  const key = `§PH${phrases.length}§`;
                  phrases.push(txt);
                  return key;
                };

                let s = raw;

                // 1) Brackets [ ... ]
                s = s.replace(/\[([^\]]+)\]/g, (_, inner) => addPhrase(inner));

                // 2) Double quotes (straight or smart)
                s = s.replace(/[“”]/g, '"');
                s = s.replace(/"([^"]+)"/g, (_, inner) => addPhrase(inner));

                // 3) Single quotes (straight or smart)
                s = s.replace(/[‘’]/g, "'");
                s = s.replace(/'([^']+)'/g, (_, inner) => addPhrase(inner));

                // Now normalize the whole string for searching
                const qNorm = normalizeSearch(s);

                // OR groups by comma
                const orGroups = qNorm
                  .split(",")
                  .map((g) => g.trim())
                  .filter(Boolean);

                const groups = orGroups.length ? orGroups : [qNorm];

                const resolveTerm = (t) => {
                  const m = t.match(/^§ph(\d+)§$/i);
                  if (!m) return t;

                  const idx = Number(m[1]);
                  const phraseRaw = phrases[idx] ?? "";
                  return normalizeSearch(phraseRaw);
                };

                // Each group becomes an array of AND-terms (tokens or phrases)
                return groups.map((g) =>
                  g
                    .split(/\s+/)
                    .map((t) => t.trim())
                    .filter(Boolean)
                    .map(resolveTerm)
                );
              };

              const matchQuery = (descRaw, qRaw) => {
                const desc = normalizeSearch(descRaw);
                const q = normalizeSearch(qRaw);

                if (q === "") return true;

                const parsed = parseQuery(qRaw); // preserves phrases before normalization

                // OR over groups
                return parsed.some((terms) => {
                  if (terms.length === 0) return false;
                  // AND over terms
                  return terms.every((t) => desc.includes(t));
                });
              };

              const applyFilter = () => {
                const qRaw = String(filterInput?.value ?? "");
                filtered = [];

                items.forEach((it, i) => {
                  const ok = matchQuery(it.desc ?? "", qRaw);

                  thumbs[i].style.display = ok ? "" : "none";
                  if (ok) filtered.push(i);
                });

                if (hitCountEl) hitCountEl.textContent = String(filtered.length);

                if (filtered.length > 0) {
                  heroFrame.style.display = "";

                  if (!filtered.includes(index)) {
                    render(filtered[0], false);
                  } else {
                    render(index, false);
                  }
                  return;
                }

                // no hits
                thumbs.forEach((t) => t.classList.remove("is-active"));
                indicator.style.opacity = "0";

                heroImg.removeAttribute("src");
                heroImg.alt = "";

                caption.innerHTML = "";
                caption.appendChild(document.createTextNode(NO_HITS_TEXT));
              };

              filterInput?.addEventListener("input", applyFilter);

              const onKeyDownMain = (e) => {
                if (e.metaKey || e.ctrlKey || e.altKey) return;

                const ae = document.activeElement;

                // ESC: leave the filter field (or any input) so gallery arrows work again
                if (e.key === "Escape") {
                  if (
                    ae &&
                    (ae.tagName === "INPUT" ||
                      ae.tagName === "TEXTAREA" ||
                      ae.isContentEditable)
                  ) {
                    ae.blur?.();
                  }
                  return;
                }

                if (filtered.length === 0) return;
                if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;

                // If user is typing/editing in an input, do NOT hijack arrow keys.
                if (
                  ae &&
                  (ae.tagName === "INPUT" ||
                    ae.tagName === "TEXTAREA" ||
                    ae.isContentEditable)
                ) {
                  return; // <-- important: no preventDefault
                }

                e.preventDefault();

                const pos = filtered.indexOf(index);
                const curPos = pos >= 0 ? pos : 0;

                if (e.key === "ArrowLeft") {
                  const wrapped = curPos === 0;
                  const nextPos = clampInFiltered(curPos - 1);
                  render(filtered[nextPos], wrapped);
                } else {
                  const wrapped = curPos === filtered.length - 1;
                  const nextPos = clampInFiltered(curPos + 1);
                  render(filtered[nextPos], wrapped);
                }
              };

              window.addEventListener("keydown", onKeyDownMain, { passive: false });
              window.addEventListener("astro:before-swap", () => {
                window.removeEventListener("keydown", onKeyDownMain);
                window.removeEventListener("keydown", onKeyDownEarly);
              });

              initialized = true;

              render(0);
              applyFilter();

              if (pendingDelta !== 0) {
                const steps = pendingDelta;
                pendingDelta = 0;
                const dirKey = steps > 0 ? "ArrowRight" : "ArrowLeft";
                for (let k = 0; k < Math.abs(steps); k++) {
                  onKeyDownMain({
                    key: dirKey,
                    metaKey: false,
                    ctrlKey: false,
                    altKey: false,
                    preventDefault() {},
                  });
                }
              }
            };

            waitForReady();
          })();
        </script>

        <div class="frame">
          <div class="filterbar" aria-label="Filter">
            <label class="filterlabel" for="personFilter">Namensfilter:</label>

            <input
              id="personFilter"
              class="filterinput"
              type="text"
              autocomplete="off"
              inputmode="text"
              placeholder=""
            />

            <div class="filtersyntax" aria-hidden="true">
              z.B. gerber | gerber a. | "gerber a." | [gerber a.] | gerber, heinzel
            </div>

            <span class="spacer" aria-hidden="true"></span>

            <div class="filtercount">
              Treffer: <span data-hit-count>{items.length}</span> / {items.length}
            </div>
          </div>

          <div class="strip-scroll" aria-label="Bildauswahl">
            <div class="strip" data-strip>
              <div class="thumb-indicator" data-thumb-indicator aria-hidden="true"></div>

              {items.map((it, idx) => (
                <button
                  class={"thumb" + (idx === 0 ? " is-active" : "")}
                  type="button"
                  data-thumb
                  data-index={idx}
                  aria-label={`Bild wählen: ${it.id.toUpperCase()}`}
                  title={it.id.toUpperCase()}
                  style={`width:${THUMB_SIZE}px;height:${THUMB_SIZE}px;flex:0 0 ${THUMB_SIZE}px;overflow:hidden;border-radius:10px;background:rgba(0,0,0,0.03);border:0;outline:none;box-shadow:none;padding:0;position:relative;z-index:1;`}
                >
                  <img
                    src={it.small}
                    alt=""
                    loading="lazy"
                    style="display:block;width:100%;height:100%;object-fit:cover;object-position:center;max-width:none;border:0;outline:0;"
                  />
                </button>
              ))}
            </div>
          </div>

          <figure class="hero">
            <button
              class="hero-btn"
              type="button"
              data-open-full
              aria-label="In neuem Tab (volle Größe) öffnen"
              title="In neuem Tab (volle Größe) öffnen"
            >
              <div class="hero-frame is-landscape" data-hero-frame>
                <img
                  src={items[0].full}
                  alt={items[0].title}
                  loading="eager"
                  data-hero-img
                />
              </div>
            </button>

            <figcaption class="caption" data-caption>
              {items[0].desc ? (
                <span class="cap-desc">
                  {splitLines(items[0].desc).map((line, i) => (
                    <>
                      {i > 0 ? <br /> : null}
                      {line}
                    </>
                  ))}
                </span>
              ) : null}
            </figcaption>
          </figure>
        </div>
      </section>
    )}
  </article>
</BaseLayout>

<style>
  .page {
    width: 100%;
    margin: 0;
  }
  .head .subtitle {
    margin: 0.25rem 0 0.75rem;
    opacity: 0.85;
  }

  .intro,
  .intro p,
  .hint {
    max-width: 800px;
  }
  .intro {
    margin: 0 0 1rem;
  }
  .hint {
    opacity: 0.75;
    margin-top: -0.25rem;
  }

  .viewer-wrap {
    max-width: 800px;
    width: min(100%, 800px);
    margin: 0;
    padding: 0;
  }

  .frame {
    width: 100%;
  }

  .filterbar {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 0 0 0.45rem;
  }

  .filterlabel {
    opacity: 0.85;
    font-size: 0.95rem;
    white-space: nowrap;
  }

  .filterinput {
    width: 170px;
    max-width: 45vw;
    padding: 8px 10px;
    border: 1px solid rgba(0, 0, 0, 0.18);
    border-radius: 10px;
    background: #fff;
    outline: none;
    box-shadow: none;
    -webkit-appearance: none;
    appearance: none;
  }
  .filterinput:focus,
  .filterinput:focus-visible {
    outline: none;
    box-shadow: none;
    border-color: rgba(0, 0, 0, 0.25);
  }

  .filtersyntax {
    opacity: 0.75;
    font-size: 0.95rem;
    white-space: nowrap;
  }

  .spacer {
    flex: 1 1 auto;
    min-width: 0;
  }

  .filtercount {
    opacity: 0.75;
    font-size: 0.95rem;
    white-space: nowrap;
    text-align: right;
  }

  .strip-scroll {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    padding-bottom: 6px;
    margin: 0 0 0.75rem;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-x: contain;
    scroll-behavior: auto;
  }

  .strip {
    position: relative;
    display: flex;
    flex-wrap: nowrap;
    gap: 10px;
    width: max-content;
    align-items: center;
    padding: 2px;
  }

  .thumb-indicator {
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    pointer-events: none;
    box-sizing: border-box;
    border-radius: 12px;

    border: 2px solid rgba(200, 0, 0, 0.9);
    z-index: 5;

    transform: translate(0px, 0px);
    transition: transform 120ms ease, width 120ms ease, height 120ms ease, opacity 120ms ease;
  }

  .thumb:focus,
  .thumb:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .hero {
    margin: 0;
  }
  .hero-btn {
    all: unset;
    display: block;
    cursor: pointer;
    width: 100%;
    background: transparent;
  }

  .hero-frame {
    width: 100%;
    background: transparent;
  }

  .hero-frame.is-landscape img {
    display: block;
    width: 100%;
    height: auto;
    border-radius: 14px;
  }

  .hero-frame.is-portrait {
    height: 520px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  .hero-frame.is-portrait img {
    display: block;
    height: 100%;
    width: auto;
    border-radius: 14px;
  }

  .caption {
    margin-top: 0.6rem;
    font-size: 0.95rem;
    opacity: 0.85;
    line-height: 1.4;
    height: 50em;
    overflow-y: auto;
    padding-right: 0.25rem;
  }
</style>
