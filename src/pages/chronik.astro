---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const fmtDate = (d: Date) => d.toLocaleDateString("sv-SE", { timeZone: "UTC" });

// 1) Landschaft
const entriesLandschaft = await getCollection("landschaft");
const landschaftItems = entriesLandschaft.map((e) => {
  const d = (e.data.updated ?? e.data.date) as Date;
  return {
    kind: "content" as const,
    title: e.data.title as string,
    subtitle: (e.data.subtitle as string | undefined) ?? "",
    date: d,
    isUpdated: Boolean(e.data.updated),
    bereich: "Landschaft",
    href: `/landschaft/${e.slug}`,
    order: typeof e.data.order === "number" ? e.data.order : 0,
  };
});

// 2) Stellen & Gebäude
const entriesOrte = await getCollection("stellen");
const orteItems = entriesOrte.map((e) => {
  const d = (e.data.updated ?? e.data.date) as Date;
  return {
    kind: "content" as const,
    title: e.data.title as string,
    subtitle: (e.data.subtitle as string | undefined) ?? "",
    date: d,
    isUpdated: Boolean(e.data.updated),
    bereich: "Stellen & Gebäude",
    href: `/stellen/${e.slug}`, // ✅ FIX
    order: typeof e.data.order === "number" ? e.data.order : 0,
  };
});

// 3) Ortschaften
const entriesOrtschaften = await getCollection("ortschaften");
const ortschaftenItems = entriesOrtschaften.map((e) => {
  const d = (e.data.updated ?? e.data.date) as Date;
  return {
    kind: "content" as const,
    title: e.data.title as string,
    subtitle: (e.data.subtitle as string | undefined) ?? "",
    date: d,
    isUpdated: Boolean(e.data.updated),
    bereich: "Ortschaften",
    href: `/ortschaften/${e.slug}`,
    order: typeof e.data.order === "number" ? e.data.order : 0,
  };
});

// 4) Geschichte (Content Collection)
const entriesGeschichte = await getCollection("geschichte");
const geschichteItems = entriesGeschichte.map((e) => {
  const d = (e.data.updated ?? e.data.date) as Date;
  return {
    kind: "content" as const,
    title: e.data.title as string,
    subtitle: (e.data.subtitle as string | undefined) ?? "",
    date: d,
    isUpdated: Boolean(e.data.updated),
    bereich: "Geschichte",
    href: `/geschichte/${e.slug}`,
    order: typeof e.data.order === "number" ? e.data.order : 0,
  };
});

// 5) Astro-Seiten mit export const chronik = {...}
const pageModules = import.meta.glob("./**/*.astro", { eager: true }) as Record<
  string,
  any
>;

const astroItems = Object.entries(pageModules)
  .filter(
    ([path]) => !path.endsWith("/chronik.astro") && path !== "./chronik.astro",
  )
  .map(([, mod]) => mod?.chronik)
  .filter(Boolean)
  .map((c: any) => ({
    kind: "page" as const,
    title: String(c.title ?? ""),
    subtitle: String(c.subtitle ?? ""),
    date: new Date(String(c.date)), // erwartet "YYYY-MM-DD"
    isUpdated: false,
    bereich: String(c.bereich ?? "Seite"),
    href: String(c.href ?? "#"),
    order: typeof c.order === "number" ? c.order : 0,
  }))
  .filter((x) => x.title && x.href && !Number.isNaN(x.date.getTime()));

// 6) Merge + Sort
const items = [
  ...landschaftItems,
  ...orteItems,
  ...ortschaftenItems,
  ...geschichteItems,
  ...astroItems,
]
  .slice()
  .sort((a, b) => {
    const ta = a.date.getTime();
    const tb = b.date.getTime();
    if (tb !== ta) return tb - ta;
    if (b.order !== a.order) return b.order - a.order;
    return a.title.localeCompare(b.title, "de");
  });
---

<BaseLayout title="Entstehung">
  <main class="chronik-page">
    <div class="chronik-top">
      <h1>Entstehung</h1>
      <p class="subtitle">
        Eine lebende Website – neueste Seiten oben, alle gezielt auffindbar
      </p>

      <section class="intro">
        <p>
          Diese Website ist eine lebende Sammlung: Sie wächst im Laufe der Zeit
          weiter, weil ständig neue Informationen, Funde und Ergänzungen
          hinzukommen können. Die Seite „Entstehung“ zeigt deshalb die gesamte
          Entwicklung der Website – alle Einträge, in zeitlicher Reihenfolge wie
          in einem Blog (die neuesten oben). So kannst du beim Wiederkommen
          sofort sehen, was seit deinem letzten Besuch neu hinzugekommen ist,
          und zugleich auch ältere Inhalte wiederfinden. Da die Liste mit der
          Zeit lang werden kann, gibt es den Filter: Er durchsucht Titel und
          Untertitel und hilft dir, die Einträge einzugrenzen – zum Beispiel
          nach einem Bereich wie „Landschaft“, „Stellen & Gebäude“,
          „Ortschaften“ oder „Geschichte“, oder nach einem Stichwort, das du im
          Titel oder Untertitel erwartest.
        </p>
      </section>
    </div>

    <!-- ✅ Sticky: bleibt stehen, aber Intro kann wegscrollen -->
    <div class="filterbar" role="search">
      <label class="filterlabel" for="chronikFilter">Filtern</label>

      <div class="filterfield">
        <input
          id="chronikFilter"
          type="search"
          placeholder="Titel oder Untertitel …"
          autocomplete="off"
          spellcheck="false"
        />
        <button
          id="chronikClear"
          class="clear"
          type="button"
          aria-label="Filter zurücksetzen"
        >
          ×
        </button>
      </div>
    </div>

    <!-- kein eigener Scroll-Container mehr; die ganze Seite scrollt -->
    <div class="listwrap" aria-label="Chronik-Liste">
      <table class="chronik">
        <colgroup>
          <col class="c-title" />
          <col class="c-bereich" />
          <col class="c-date" />
        </colgroup>

        <thead>
          <tr>
            <th>Titel</th>
            <th>Bereich</th>
            <th>Datum</th>
          </tr>
        </thead>

        <tbody>
          {
            items.map((e) => {
              const q = `${e.title} ${e.subtitle} ${e.bereich} ${fmtDate(e.date)}`.toLowerCase();
              return (
                <tr data-q={q}>
                  <td>
                    <a class="title-link" href={e.href}>{e.title}</a>
                    {e.subtitle ? (
                      <div class="subtitle-inline">{e.subtitle}</div>
                    ) : null}
                  </td>

                  <td class="bereich">{e.bereich}</td>

                  <td class="date-cell">
                    <span class="date-text">{fmtDate(e.date)}</span>
                    {e.isUpdated ? (
                      <span class="badge" title="Updated">↻</span>
                    ) : null}
                  </td>
                </tr>
              );
            })
          }
        </tbody>
      </table>
    </div>

    <script>
      const inputEl = document.querySelector("#chronikFilter");
      const clearEl = document.querySelector("#chronikClear");

      if (
        inputEl instanceof HTMLInputElement &&
        clearEl instanceof HTMLButtonElement
      ) {
        const rows = Array.from(
          document.querySelectorAll("table.chronik tbody tr"),
        ).filter((el) => el instanceof HTMLTableRowElement);

        const setClearVisible = () => {
          clearEl.style.visibility = inputEl.value ? "visible" : "hidden";
        };

        const applyFilter = () => {
          const q = inputEl.value.trim().toLowerCase();
          for (const tr of rows) {
            const hay = tr.dataset.q ?? "";
            tr.hidden = q ? !hay.includes(q) : false;
          }
          setClearVisible();
        };

        let timerId: number | undefined;

        const schedule = () => {
          if (timerId !== undefined) window.clearTimeout(timerId);
          timerId = window.setTimeout(applyFilter, 80);
        };

        inputEl.addEventListener("input", schedule);

        clearEl.addEventListener("click", () => {
          inputEl.value = "";
          applyFilter();
          inputEl.focus();
        });

        inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            inputEl.value = "";
            applyFilter();
            inputEl.focus();
          }
        });

        setClearVisible();
      }
    </script>
  </main>
</BaseLayout>

<style>
  /* ✅ Jetzt scrollt die ganze Chronik-Seite */
  .chronik-page {
    max-width: 980px;
    margin: 0 auto;
    padding: 0 0.25rem;

    height: 100vh;
    overflow: auto;

    /* macOS Overlay-Scrollbar kann Inhalte überdecken -> etwas Luft rechts */
    padding-right: 14px;
    scrollbar-gutter: stable;

    /* Luft unten, damit das Ende nicht "abgeschnitten" wirkt */
    padding-bottom: 1.25rem;
  }

  h1 {
    margin-bottom: 0.3rem;
  }

  .subtitle {
    margin: 0.25rem 0 1.25rem;
    font-size: 1.15rem;
    opacity: 0.8;
  }

  .intro {
    max-width: 860px;
    margin-bottom: 1.25rem;
  }

  /* ✅ Hier soll es "stehen bleiben" */
  .filterbar {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #fff;

    display: flex;
    align-items: center;
    gap: 0.75rem;

    margin: 0 0 0.9rem 0;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(0, 0, 0, 0.06);
  }

  .filterlabel {
    color: rgba(0, 0, 0, 0.6);
    font-size: 0.92rem;
    white-space: nowrap;
  }

  .filterfield {
    position: relative;
    flex: 1;
  }

  #chronikFilter {
    width: 100%;
    padding: 0.55rem 2rem 0.55rem 0.7rem;
    border: 1px solid rgba(0, 0, 0, 0.18);
    border-radius: 10px;
    font-size: 0.98rem;
  }

  #chronikFilter::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
    display: none;
  }
  #chronikFilter::-webkit-search-decoration {
    -webkit-appearance: none;
    appearance: none;
    display: none;
  }

  #chronikFilter:focus {
    outline: none;
    border-color: rgba(0, 0, 0, 0.35);
  }

  .clear {
    position: absolute;
    right: 0.35rem;
    top: 50%;
    transform: translateY(-50%);
    width: 1.6rem;
    height: 1.6rem;
    border: 0;
    border-radius: 999px;
    background: transparent;
    font-size: 1.25rem;
    line-height: 1;
    color: rgba(0, 0, 0, 0.55);
    cursor: pointer;
    visibility: hidden;
  }

  .clear:hover {
    background: rgba(0, 0, 0, 0.06);
  }

  table.chronik {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    font-size: 0.98rem;
  }

  col.c-title { width: auto; }
  col.c-bereich { width: 10%; }
  col.c-date { width: 10ch; }

  /* ✅ Tabellenkopf bleibt beim Scrollen sichtbar (innerhalb .chronik-page) */
  thead th {
    text-align: left;
    font-weight: 600;
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.15);
    white-space: nowrap;

    position: sticky;
    top: 3.15rem; /* ungefähr Höhe der Filterbar inkl. Padding */
    background: #fff;
    z-index: 2;
  }

  table.chronik th:first-child,
  table.chronik td:first-child {
    padding-left: 0;
  }

  table.chronik th:last-child,
  table.chronik td:last-child {
    padding-right: 0;
  }

  table.chronik thead th:nth-child(3),
  table.chronik tbody td:nth-child(3) {
    text-align: right !important;
    white-space: nowrap;
    font-variant-numeric: tabular-nums;
  }

  tbody td {
    padding-top: 0.62rem;
    padding-bottom: 0.62rem;
    padding-right: 0.75rem;
    padding-left: 0.75rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    vertical-align: top;
  }

  .title-link {
    display: block;
    font-weight: 650;
    text-decoration: none;
    line-height: 1.2;
    margin: 0;
  }

  .title-link:hover {
    text-decoration: underline;
  }

  .subtitle-inline {
    margin-top: 0.22rem;
    line-height: 1.25;
    font-size: 0.88rem;
    color: rgba(0, 0, 0, 0.55);
  }

  td.bereich {
    white-space: nowrap;
    color: rgba(0, 0, 0, 0.55);
    font-size: 0.9rem;
  }

  .badge {
    display: inline-block;
    margin-left: 0.4rem;
    font-size: 0.9rem;
    color: rgba(0, 0, 0, 0.45);
  }
</style>
