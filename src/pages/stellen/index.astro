---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

// base-safe URL prefix ("/" in dev, "/pechgruen-website/" on GitHub Pages build when base is set)
const BASE = import.meta.env.BASE_URL;
const u = (p: string) => `${BASE}${p.replace(/^\/+/, "")}`;

// Damit es in der Chronik auftaucht:
export const chronik = {
  title: "Stellen & Gebäude",
  subtitle: "Einstieg über das Luftbild 1946",
  date: "2025-12-18",
  order: 0,
  updated: "2026-01-05",
  bereich: "Stellen & Gebäude",
  href: "/stellen",
};

const tileSource = "/tiles/luftbild-1946/1946.dzi";

// Fixes Start-Zentrum (Haus 24 Koordinaten)
const centerPoint = { x: 4052, y: 7040 };
const startZoomFactor = 4.5;

// Marker aus src/content/stellen/*.md
const entries = await getCollection("stellen");
const points = entries.map((e) => ({
  slug: e.slug,
  title: e.data.title as string,
  subtitle: String((e.data as any).subtitle ?? ""),
  label: String((e.data as any).label ?? ""),
  x: (e.data as any).x as number,
  y: (e.data as any).y as number,
  href: `/stellen/${e.slug}`,
}));
---

<BaseLayout title="Stellen & Gebäude">
  <main
    style="
      max-width:980px;
      margin:0 auto;
      padding-bottom:0;
    "
  >
    <!-- Top: Titel + Untertitel + stille Einstiege -->
    <header id="stellen-top">
      <h1 style="margin:0 0 0.35rem;">Stellen &amp; Gebäude</h1>

      <div
        id="stellen-subrow"
        style="
          display:flex;
          align-items:baseline;
          justify-content:space-between;
          gap:1rem;
          margin:0 0 0.75rem;
          opacity:0.8;
        "
      >
        <div id="stellen-subtitle" style="margin:0;">
          Einstieg über das Luftbild von Mai 1946 – Marker führen zu
          Detailseiten.
        </div>

        <div
          id="stellen-links"
          style="
            display:flex;
            gap:0.8rem;
            white-space:nowrap;
          "
        >
          <button
            id="open-einordnung"
            type="button"
            style="
              font: inherit;
              color: inherit;
              background: transparent;
              border: 0;
              padding: 0;
              margin: 0;
              cursor: pointer;
            "
          >
            Einordnung
          </button>
          <button
            id="open-bedienung"
            type="button"
            style="
              font: inherit;
              color: inherit;
              background: transparent;
              border: 0;
              padding: 0;
              margin: 0;
              cursor: pointer;
            "
          >
            Bedienung
          </button>
        </div>
      </div>
    </header>

    <!-- Viewer -->
    <div
      id="osd"
      style="
        width:100%;
        height:640px; /* wird per JS dynamisch gesetzt */
        background:#000;
        border-radius:12px;
        overflow:hidden;
        position:relative;
        margin:0;
      "
    >
      <!-- Marker-Toggle direkt im Bild (Start: Marker AUS) -->
      <button
        id="toggle-markers"
        type="button"
        style="
          position:absolute;
          right:6px;
          bottom:6px;
          z-index:10;
          font: inherit;
          padding: 0.35rem 0.6rem;
          border-radius: 10px;
          border: 1px solid rgba(0,0,0,0.25);
          background: rgba(255,255,255,0.85);
          backdrop-filter: blur(4px);
          cursor: pointer;
        "
        aria-pressed="true"
      >
        Marker einblenden
      </button>

      <!-- Versteckte Koordinaten-Anzeige (nur bei Option/Alt+Klick) -->
      <div
        id="coord-toast"
        style="
          position:absolute;
          left:8px;
          bottom:8px;
          z-index:10;
          font: 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
          padding: 0.25rem 0.5rem;
          border-radius: 10px;
          border: 1px solid rgba(0,0,0,0.25);
          background: rgba(255,255,255,0.85);
          backdrop-filter: blur(4px);
          display:none;
          user-select:text;
          pointer-events:none;
        "
        aria-hidden="true"
      >
      </div>
    </div>

    <!-- Leseebene (Overlay) -->
    <div
      id="info-overlay"
      aria-hidden="true"
      style="
        position:fixed;
        inset:0;
        z-index:1000;
        display:none;
        align-items:stretch;
        justify-content:center;
        padding: 18px;
        background: rgba(255,255,255,0.92);
        backdrop-filter: blur(6px);
      "
    >
      <div
        id="info-panel"
        role="dialog"
        aria-modal="true"
        style="
          width: min(980px, 100%);
          max-height: 100%;
          overflow: auto;
          background: rgba(255,255,255,0.98);
          border: 1px solid rgba(0,0,0,0.12);
          border-radius: 14px;
          box-shadow: 0 18px 50px rgba(0,0,0,0.18);
          padding: 18px 18px 16px;
          position: relative;
        "
      >
        <button
          id="close-overlay"
          type="button"
          aria-label="Close"
          style="
            position:absolute;
            right:10px;
            top:10px;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.18);
            background: rgba(255,255,255,0.92);
            cursor: pointer;
            font: 16px/1 -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
          "
        >
          ×
        </button>

        <div id="overlay-body">
          <!-- wird per JS befüllt -->
        </div>
      </div>

      <!-- Inhalte bleiben vollständig erhalten (nur nicht im Seitenfluss) -->
      <template id="tpl-einordnung">
        <h2 style="margin:0 0 0.8rem;">Einordnung</h2>

        <p>
          Diese Seite zeigt eine <strong
            >außergewöhnliche Luftaufnahme des Dorfes Pechgrün</strong
          >, aufgenommen im <strong>Mai 1946</strong>. Außergewöhnlich ist
          dieses Bild nicht nur wegen seiner für die Zeit bemerkenswerten
          technischen Qualität, sondern vor allem wegen des
          <strong>Zeitpunkts</strong>, zu dem es entstanden ist: nach der
          Zwangsaussiedlung eines großen Teils der Bevölkerung, aber noch bevor
          baulicher Verfall, Abriss und spätere Zerstörung einsetzten.
        </p>

        <p>
          Frühere Luftaufnahmen dieses Ortes existieren nicht. Erst im Verlauf
          des Zweiten Weltkriegs begann die systematische Luftbildfotografie.
          Spätere Aufnahmen hätten Pechgrün bereits verändert gezeigt. Dass
          ausgerechnet für das Jahr 1946 eine derart detailreiche Aufnahme
          erhalten ist, stellt einen <strong>seltenen Glücksfall</strong> dar.
        </p>

        <p>
          Zusammen mit der ungewöhnlich hohen Bildqualität wird diese Aufnahme
          zu einem
          <strong>Schlüsselbild</strong>: Sie erlaubt es, das Dorf konkret zu
          sehen – so, wie es war, als dort noch Menschen lebten.
        </p>
      </template>

      <template id="tpl-bedienung">
        <h2 style="margin:0 0 0.8rem;">Bedienung</h2>

        <p style="margin-top:0;">
          „Bedienung“ beschreibt sowohl die Navigation im Luftbild (Zoomen,
          Verschieben) als auch den Umgang mit Markern und deren Detailseiten.
        </p>

        <h3 style="margin:1.25rem 0 0.5rem;">Hausnummern und Marker</h3>

        <p>
          Die Hausnummern sind <strong>fest in das Luftbild eingetragen</strong
          >. Sie folgen der historischen Nummerierung des Dorfes und lassen sich
          nicht ein- oder ausblenden. Grundlage der Zuordnung ist ein
          <strong>handschriftlicher Ortsplan von Karl Redelbach</strong>, der
          für die Pechgrüner Erinnerungsbücher angefertigt wurde. Erst dieser
          Plan macht es möglich, die schriftlichen Quellen räumlich zu verorten.
        </p>

        <p>
          Zusätzlich gibt es <strong>Marker</strong>, die du über den Button
          rechts unten
          <strong>explizit einschalten</strong> kannst. Diese Marker kennzeichnen
          Stellen und Gebäude, zu denen bereits <strong
            >Detailseiten mit Zusatzinformationen</strong
          > existieren (z.&nbsp;B. aus Erinnerungsbüchern, Einwohnermeldebuch und
          Kirchenbüchern). Ein Klick auf einen Marker führt direkt zur entsprechenden
          Detailseite.
        </p>

        <p>
          Die Detailseiten entstehen <strong>nach und nach</strong>. Ihre
          Erstellung erfordert Zeit und sorgfältige Arbeit; deshalb sind bislang
          nur einige Punkte mit eigenen Seiten versehen. Mit fortschreitender
          Arbeit werden Schritt für Schritt weitere Detailseiten hinzukommen –
          und damit auch weitere Marker im Luftbild sichtbar werden.
        </p>

        <h3 style="margin:1.25rem 0 0.5rem;">Navigation</h3>
        <ul style="margin-top:0.25rem;">
          <li>
            <strong>Zoomen:</strong>
            mit Trackpad (Zwei-Finger-Geste) oder mit dem Mausrad
          </li>
          <li>
            <strong>Verschieben (Panning):</strong>
            <span style="white-space:nowrap;">Maus:</span> linke Taste gedrückt halten
            und ziehen &nbsp;–&nbsp;
            <span style="white-space:nowrap;">Trackpad:</span> gedrückt halten und
            ziehen
          </li>
          <li>
            <strong>Doppelklick:</strong>
            hineinzoomen &nbsp;–&nbsp;
            <strong>Shift&nbsp;+&nbsp;Doppelklick:</strong> wieder herauszoomen
          </li>
          <li>
            <strong>Marker ein-/ausblenden:</strong>
            Button rechts unten („Marker einblenden“ / „Marker ausblenden“)
          </li>
          <li>
            <strong>Detailseite öffnen:</strong>
            Marker anklicken
          </li>
        </ul>
      </template>
    </div>

    <!-- GLOBAL: Overlays klickbar -->
    <style is:global>
      #osd .openseadragon-overlay,
      #osd .openseadragon-overlay a,
      #osd .openseadragon-overlay button {
        pointer-events: auto !important;
      }
    </style>
  </main>

  <!-- base-safe vendor path -->
  <script is:inline src={u("vendor/openseadragon.min.js")}></script>

  <script define:vars={{ tileSource, centerPoint, startZoomFactor, points }}>
    // @ts-ignore
    const OSD = window.OpenSeadragon;

    const host = document.getElementById("osd");
    const toast = document.getElementById("coord-toast");

    const overlay = document.getElementById("info-overlay");
    const overlayBody = document.getElementById("overlay-body");
    const closeOverlayBtn = document.getElementById("close-overlay");
    const openEinordnungBtn = document.getElementById("open-einordnung");
    const openBedienungBtn = document.getElementById("open-bedienung");
    const tplEinordnung = document.getElementById("tpl-einordnung");
    const tplBedienung = document.getElementById("tpl-bedienung");

    const viewer = OSD({
      element: host,
      tileSources: tileSource,
      showNavigationControl: false,
      wrapHorizontal: false,
      wrapVertical: false,
      constrainDuringPan: true,
      visibilityRatio: 1.0,
      zoomPerScroll: 1.04,
      gestureSettingsMouse: {
        scrollToZoom: true,
        clickToZoom: false,
        dblClickToZoom: true,
        pinchToZoom: true,
        flickEnabled: true,
      },
    });

    function saveView() {
      try {
        const c = viewer.viewport.getCenter(true); // viewport coords
        const z = viewer.viewport.getZoom(true); // absolute zoom
        sessionStorage.setItem(
          VIEW_KEY,
          JSON.stringify({ z, c: { x: c.x, y: c.y } })
        );
      } catch (_) {}
    }

    function loadView() {
      try {
        const raw = sessionStorage.getItem(VIEW_KEY);
        if (!raw) return null;
        const v = JSON.parse(raw);
        if (!v || typeof v.z !== "number" || !v.c) return null;
        if (typeof v.c.x !== "number" || typeof v.c.y !== "number") return null;
        return v;
      } catch (_) {
        return null;
      }
    }

    /* -----------------------------------------
       Dynamische Höhe: messen (nicht rechnen)
       ----------------------------------------- */
    let heightRAF = null;

    function updateViewerHeight() {
      if (!host) return;

      const r = host.getBoundingClientRect();
      const minH = 200;

      // Robust: messe wirklich, wie viel Platz bis zum Viewport-Bottom übrig ist
      // und ziehe etwas Safety ab, damit garantiert kein Page-Scroll übrig bleibt.
      const safety = 80; // <- wenn du "100px Sicherheit" willst: 100
      const available = window.innerHeight - r.top;

      const h = Math.max(minH, Math.floor(available - safety));
      host.style.height = `${h}px`;

      try {
        const size = new OSD.Point(host.clientWidth, host.clientHeight);
        viewer.viewport.resize(size, true);
        viewer.viewport.applyConstraints(true);
        viewer.forceRedraw();
      } catch (_) {}
    }

    function scheduleViewerHeightUpdate() {
      if (heightRAF) cancelAnimationFrame(heightRAF);
      heightRAF = requestAnimationFrame(updateViewerHeight);
    }

    window.addEventListener("resize", scheduleViewerHeightUpdate, {
      passive: true,
    });

    /* ---------------------------
       Tooltip-Layer (zweizeilig)
       --------------------------- */
    const tip = document.createElement("div");
    tip.id = "marker-tip";
    tip.style.position = "absolute";
    tip.style.zIndex = "20";
    tip.style.pointerEvents = "none";
    tip.style.display = "none";
    tip.style.maxWidth = "360px";
    tip.style.padding = "8px 10px";
    tip.style.borderRadius = "12px";
    tip.style.border = "1px solid rgba(0,0,0,0.25)";
    tip.style.background = "rgba(255,255,255,0.92)";
    tip.style.backdropFilter = "blur(4px)";
    tip.style.boxShadow = "0 8px 22px rgba(0,0,0,0.20)";
    tip.style.font =
      "13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
    tip.style.color = "#111";
    host.appendChild(tip);

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function showTip(title, subtitle, clientX, clientY) {
      const r = host.getBoundingClientRect();
      const t = title || "";
      const s = subtitle || "";

      tip.innerHTML = `
        <div style="font-size:14px; font-weight:600; line-height:1.15;">
          ${escapeHtml(t)}
        </div>
        ${
          s
            ? `<div style="font-size:12px; opacity:0.85; line-height:1.2; margin-top:2px;">
                 ${escapeHtml(s)}
               </div>`
            : ""
        }
      `;

      tip.style.display = "block";

      const pad = 8;
      let x = clientX - r.left + 12;
      let y = clientY - r.top - 12;

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;

      const tr = tip.getBoundingClientRect();
      const maxX = r.width - tr.width - pad;
      const maxY = r.height - tr.height - pad;

      x = Math.max(pad, Math.min(x, maxX));
      y = Math.max(pad, Math.min(y, maxY));

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function hideTip() {
      tip.style.display = "none";
    }

    /* -----------------------------------------
       Marker: Button statt <a> (keine Statusbar)
       ----------------------------------------- */
    function makeSvgMarker(label, title, subtitle, href) {
      const wrap = document.createElement("button");
      wrap.type = "button";

      wrap.style.width = "30px";
      wrap.style.height = "30px";
      wrap.style.display = "block";
      wrap.style.pointerEvents = "auto";
      wrap.style.cursor = "pointer";
      wrap.style.textDecoration = "none";
      wrap.style.touchAction = "manipulation";
      wrap.style.padding = "0";
      wrap.style.border = "0";
      wrap.style.background = "transparent";

      const aria = subtitle ? `${title} – ${subtitle}` : title;
      wrap.setAttribute("aria-label", aria);

      wrap.addEventListener("pointerenter", (e) => {
        showTip(title, subtitle, e.clientX, e.clientY);
      });
      wrap.addEventListener("pointermove", (e) => {
        showTip(title, subtitle, e.clientX, e.clientY);
      });
      wrap.addEventListener("pointerleave", () => {
        hideTip();
      });

      const go = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        hideTip();
        saveView();
        window.location.assign(href);
      };

      wrap.addEventListener("pointerdown", go, true);
      wrap.addEventListener("click", go, true);

      wrap.innerHTML = `
        <svg width="30" height="30" viewBox="0 0 30 30" style="pointer-events:none;">
          <circle cx="15" cy="15" r="13" fill="#fff" stroke="#000" stroke-width="1"/>
          <text x="15" y="15" text-anchor="middle" dominant-baseline="middle" dx="-0.03em" dy="0.11em"
                font-size="12" font-weight="500">${label}</text>
        </svg>`;
      return wrap;
    }

    let item = null;
    const MARKER_KEY = "stellen_markers_visible";
    let markersVisible = sessionStorage.getItem(MARKER_KEY) === "1";
    const VIEW_KEY = "stellen_view_v1"; // zoom + center (viewport coords)

    function addMarkers() {
      viewer.clearOverlays();
      for (const p of points) {
        const imgPt = new OSD.Point(p.x, p.y);
        const vpPt = item.imageToViewportCoordinates(imgPt);
        viewer.addOverlay({
          element: makeSvgMarker(p.label, p.title, p.subtitle, p.href),
          location: vpPt,
          placement: OSD.Placement.CENTER,
        });
      }
    }

    function setMarkersVisible(v) {
      markersVisible = v;
      sessionStorage.setItem(MARKER_KEY, v ? "1" : "0");

      if (v) addMarkers();
      else {
        viewer.clearOverlays();
        hideTip();
      }

      toggleBtn.textContent = v ? "Marker ausblenden" : "Marker einblenden";
      toggleBtn.setAttribute("aria-pressed", String(!v));
    }

    const toggleBtn = document.getElementById("toggle-markers");
    toggleBtn.addEventListener("click", () =>
      setMarkersVisible(!markersVisible)
    );

    // Versteckte Funktion: Option/Alt + Klick -> Bildkoordinaten anzeigen (und kopieren)
    let toastTimer = null;

    function showCoords(x, y) {
      if (!toast) return;
      toast.textContent = `x=${x}, y=${y}`;
      toast.style.display = "block";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toast.style.display = "none";
      }, 10000);
    }

    async function copyCoordsToClipboard(text) {
      try {
        if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        }
      } catch (_) {}
    }

    viewer.addHandler("canvas-click", (ev) => {
      const oe = ev && ev.originalEvent;
      const isOption = !!(oe && oe.altKey); // Option auf macOS = altKey
      if (!isOption) return;

      ev.preventDefaultAction = true;
      if (oe && oe.stopPropagation) oe.stopPropagation();

      const currentItem = viewer.world.getItemAt(0);
      if (!currentItem) return;

      const webPoint = ev.position; // Pixel relativ zum Viewer-Element
      const vpPoint = viewer.viewport.pointFromPixel(webPoint);
      const imgPoint = currentItem.viewportToImageCoordinates(vpPoint);

      const x = Math.round(imgPoint.x);
      const y = Math.round(imgPoint.y);

      showCoords(x, y);
      copyCoordsToClipboard(`${x},${y}`);
    });

    /* -----------------------------------------
       Overlay: Texte auf Abruf
       ----------------------------------------- */
    function openOverlay(which) {
      if (!overlay || !overlayBody) return;

      overlayBody.innerHTML = "";
      const tpl = which === "einordnung" ? tplEinordnung : tplBedienung;
      if (tpl && tpl.content) {
        overlayBody.appendChild(tpl.content.cloneNode(true));
      }

      overlay.style.display = "flex";
      overlay.setAttribute("aria-hidden", "false");

      // Scrollen im Hintergrund unterbinden
      document.documentElement.style.overflow = "hidden";
      document.body.style.overflow = "hidden";

      // Fokus
      if (closeOverlayBtn && closeOverlayBtn.focus) closeOverlayBtn.focus();
    }

    function closeOverlay() {
      if (!overlay) return;
      overlay.style.display = "none";
      overlay.setAttribute("aria-hidden", "true");

      document.documentElement.style.overflow = "";
      document.body.style.overflow = "";
    }

    openEinordnungBtn.addEventListener("click", () =>
      openOverlay("einordnung")
    );
    openBedienungBtn.addEventListener("click", () => openOverlay("bedienung"));
    closeOverlayBtn.addEventListener("click", closeOverlay);

    // Klick auf Hintergrund schließt (Panel selbst nicht)
    overlay.addEventListener("pointerdown", (e) => {
      if (e.target === overlay) closeOverlay();
    });

    // ESC schließt
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay && overlay.style.display !== "none") {
        closeOverlay();
      }
    });

    viewer.addHandler("open", () => {
      item = viewer.world.getItemAt(0);

      // Höhe nach dem Layout + OSD-open setzen
      scheduleViewerHeightUpdate();

      const home = viewer.viewport.getHomeZoom();
      viewer.viewport.minZoomLevel = home;
      viewer.viewport.maxZoomLevel = home * 32;

      const saved = loadView();

      if (saved) {
        const vpCenter = new OSD.Point(saved.c.x, saved.c.y);
        viewer.viewport.panTo(vpCenter, true);
        viewer.viewport.zoomTo(saved.z, vpCenter, true);
      } else {
        const imgCenter = new OSD.Point(centerPoint.x, centerPoint.y);
        const vpCenter = item.imageToViewportCoordinates(imgCenter);
        viewer.viewport.panTo(vpCenter, true);
        viewer.viewport.zoomTo(home * startZoomFactor, vpCenter, true);
      }

      // Initial: Marker-Zustand wiederherstellen
      setMarkersVisible(markersVisible);
    });

    // Erstes Layout-Setzen (falls OSD open minimal verzögert ist)
    scheduleViewerHeightUpdate();
  </script>
</BaseLayout>
