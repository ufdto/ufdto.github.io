---
type Marker = {
  id: string;
  x: number;
  y: number;
  label?: string;
  title?: string;
  subtitle?: string;
  href?: string;
};

type StartView =
  | { type: "home" }
  | { type: "centerZoom"; x: number; y: number; zoomFactor: number }
  | {
      type: "rect";
      x: number;
      y: number;
      w: number;
      h: number;
      zoomFactor?: number;
    };

const {
  id,
  tileSource,
  markers = [],
  markersDefaultVisible = false,
  showMarkersToggle = true,
  authorMode = true,
  startView = { type: "home" },
  height = 640,
} = Astro.props as {
  id: string;
  tileSource: string | Record<string, any>;
  markers?: Marker[];
  markersDefaultVisible?: boolean;
  showMarkersToggle?: boolean;
  authorMode?: boolean;
  startView?: StartView;
  height?: number;
};

const RAW_BASE = import.meta.env.BASE_URL;
const BASE = RAW_BASE.endsWith("/") ? RAW_BASE : RAW_BASE + "/";
const u = (p: string) => `${BASE}${p.replace(/^\/+/, "")}`;

const tileSourceFixed =
  typeof tileSource === "string" ? u(tileSource) : tileSource;
---

<div
  id={id}
  style={`
    width:100%;
    height:${height}px;
    background:#000;
    border-radius:12px;
    overflow:hidden;
    position:relative;
  `}
>
  {
    showMarkersToggle && (
      <button
        type="button"
        data-dz-toggle
        style="
        position:absolute;
        right:6px;
        bottom:6px;
        z-index:10;
        font: inherit;
        padding: 0.35rem 0.6rem;
        border-radius: 10px;
        border: 1px solid rgba(0,0,0,0.25);
        background: rgba(255,255,255,0.85);
        backdrop-filter: blur(4px);
        cursor: pointer;
      "
        aria-pressed={markersDefaultVisible}
      >
        Marker einblenden
      </button>
    )
  }

  <div
    data-dz-toast
    style="
      position:absolute;
      left:8px;
      bottom:8px;
      z-index:10;
      font: 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      padding: 0.25rem 0.5rem;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.25);
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(4px);
      display:none;
      user-select:text;
      pointer-events:none;
    "
    aria-hidden="true"
  >
  </div>
</div>

<script is:inline src={u("vendor/openseadragon.min.js")}></script>

<script
  define:vars={{
    id,
    tileSource: tileSourceFixed,
    markers,
    markersDefaultVisible,
    showMarkersToggle,
    authorMode,
    startView,
  }}
>
  // @ts-ignore
  const OSD = window.OpenSeadragon;
  const host = document.getElementById(id);

  if (!host || !OSD) {
    // silent fail
  } else {
    const styleId = `dz-pe-${id}`;
    if (!document.getElementById(styleId)) {
      const s = document.createElement("style");
      s.id = styleId;
      s.textContent = `
        #${id} .openseadragon-overlay,
        #${id} .openseadragon-overlay * {
          pointer-events: auto !important;
        }
      `;
      document.head.appendChild(s);
    }

    const toggleBtn = host.querySelector("[data-dz-toggle]");
    const toast = host.querySelector("[data-dz-toast]");

    const viewer = OSD({
      element: host,
      tileSources: tileSource,
      showNavigationControl: false,
      wrapHorizontal: false,
      wrapVertical: false,
      constrainDuringPan: true,
      visibilityRatio: 1.0,
      zoomPerScroll: 1.04,
      gestureSettingsMouse: {
        scrollToZoom: true,
        clickToZoom: false,
        dblClickToZoom: true,
        pinchToZoom: true,
        flickEnabled: true,
      },
    });

    let BASE_ZOOM = null;
    let MANUAL_MIN = null;
    let MANUAL_MAX = null;

    const tip = document.createElement("div");
    tip.id = "marker-tip";
    tip.style.position = "absolute";
    tip.style.zIndex = "20";
    tip.style.pointerEvents = "none";
    tip.style.display = "none";
    tip.style.maxWidth = "360px";
    tip.style.padding = "8px 10px";
    tip.style.borderRadius = "12px";
    tip.style.border = "1px solid rgba(0,0,0,0.25)";
    tip.style.background = "rgba(255,255,255,0.92)";
    tip.style.backdropFilter = "blur(4px)";
    tip.style.boxShadow = "0 8px 22px rgba(0,0,0,0.20)";
    tip.style.font =
      "13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
    tip.style.color = "#111";
    host.appendChild(tip);

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    /* ============================================================
       PINNED TOOLTIP + FREEZE (für Fly-to)
       ============================================================ */
    let pinned = false;
    let pinnedMarkerId = null;

    function showTip(title, subtitle, clientX, clientY) {
      if (pinned) return;

      const r = host.getBoundingClientRect();
      const t = title || "";
      const s = subtitle || "";

      tip.innerHTML = `
        <div style="font-size:14px; font-weight:600; line-height:1.15;">
          ${escapeHtml(t)}
        </div>
        ${
          s
            ? `<div style="font-size:12px; opacity:0.85; line-height:1.2; margin-top:2px;">
                 ${escapeHtml(s)}
               </div>`
            : ""
        }
      `;

      tip.style.display = "block";

      const pad = 8;
      let x = clientX - r.left + 12;
      let y = clientY - r.top - 12;

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;

      const tr = tip.getBoundingClientRect();
      const maxX = r.width - tr.width - pad;
      const maxY = r.height - tr.height - pad;

      x = Math.max(pad, Math.min(x, maxX));
      y = Math.max(pad, Math.min(y, maxY));

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function hideTip() {
      if (pinned) return;
      tip.style.display = "none";
    }

    function setFrozen(v) {
      viewer.setMouseNavEnabled(!v);
      host.style.cursor = v ? "default" : "";
    }

    function closePinnedTip() {
      if (!pinned) return;
      pinned = false;
      tip.style.display = "none";
      tip.style.pointerEvents = "none";
      setFrozen(false);

      // ✅ Event für die Liste (Highlight entfernen)
      window.dispatchEvent(new CustomEvent("dz:pinned-close", {
        detail: { mapId: id, id: pinnedMarkerId }
      }));

      pinnedMarkerId = null;
    }

    function showPinnedTipAt(title, subtitle, vpPoint, markerId) {
      const t = title || "";
      const s = subtitle || "";

      pinned = true;
      pinnedMarkerId = markerId || null;
      setFrozen(true);

      tip.innerHTML = `
        <div style="display:flex; align-items:flex-start; gap:10px;">
          <div style="min-width:0;">
            <div style="font-size:14px; font-weight:600; line-height:1.15;">
              ${escapeHtml(t)}
            </div>
            ${
              s
                ? `<div style="font-size:12px; opacity:0.85; line-height:1.2; margin-top:2px;">
                     ${escapeHtml(s)}
                   </div>`
                : ""
            }
          </div>
          <button type="button" data-tip-close
            style="
              all:unset;
              cursor:pointer;
              font-size:16px;
              line-height:1;
              padding:2px 6px;
              border-radius:8px;
              opacity:0.65;
              user-select:none;
            "
            aria-label="Tooltip schließen"
            title="Schließen"
          >×</button>
        </div>
      `;

      tip.style.pointerEvents = "auto";
      tip.style.display = "block";

      const r = host.getBoundingClientRect();
      const px = viewer.viewport.pixelFromPoint(vpPoint, true);

      const pad = 8;
      let x = px.x + 14;
      let y = px.y - 14;

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;

      const tr = tip.getBoundingClientRect();
      const maxX = r.width - tr.width - pad;
      const maxY = r.height - tr.height - pad;

      x = Math.max(pad, Math.min(x, maxX));
      y = Math.max(pad, Math.min(y, maxY));

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;

      const btn = tip.querySelector("[data-tip-close]");
      if (btn) btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        closePinnedTip();
      }, { once: true });

      const onDoc = (e) => {
        if (!pinned) return;
        if (tip.contains(e.target)) return;
        closePinnedTip();
        document.removeEventListener("pointerdown", onDoc, true);
      };
      document.addEventListener("pointerdown", onDoc, true);
    }

    /* -----------------------------------------
       Marker: Button statt <a> (keine Statusbar)
       ----------------------------------------- */
    function makeMarkerElement(m) {
      const title = m.title || "";
      const subtitle = m.subtitle || "";
      const aria = subtitle ? `${title} – ${subtitle}` : title;

      const el = document.createElement("button");
      el.type = "button";

      el.style.width = "30px";
      el.style.height = "30px";
      el.style.display = "block";
      el.style.pointerEvents = "auto";
      el.style.touchAction = "manipulation";
      el.style.padding = "0";
      el.style.border = "0";
      el.style.background = "transparent";
      el.style.cursor = m.href ? "pointer" : "default";

      el.setAttribute("aria-label", aria || m.label || "");

      if (title || subtitle) {
        const onMove = (e) => showTip(title, subtitle, e.clientX, e.clientY);
        const onLeave = () => hideTip();

        el.addEventListener("pointerenter", onMove);
        el.addEventListener("pointermove", onMove);
        el.addEventListener("pointerleave", onLeave);

        el.addEventListener("mouseenter", onMove);
        el.addEventListener("mousemove", onMove);
        el.addEventListener("mouseleave", onLeave);
      }

      el.innerHTML = `
        <svg style="pointer-events:none" width="30" height="30" viewBox="0 0 30 30">
          <circle style="pointer-events:none" cx="15" cy="15" r="13" fill="#fff" stroke="#000" stroke-width="1"/>
          <text style="pointer-events:none" x="15" y="15" text-anchor="middle" dominant-baseline="middle"
                dx="-0.03em" dy="0.11em" font-size="12" font-weight="500">${m.label ?? ""}</text>
        </svg>`;

      const stop = (e) => e.stopPropagation();
      [
        "pointerdown",
        "pointerup",
        "mousedown",
        "mouseup",
        "touchstart",
        "touchend",
      ].forEach((evt) => el.addEventListener(evt, stop, { passive: false }));

      if (m.href) {
        const go = (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          hideTip();
          window.location.assign(m.href);
        };

        el.addEventListener("pointerdown", go, true);
        el.addEventListener("click", go, true);
      }

      return el;
    }

    let item = null;
    let markersVisible = !!markersDefaultVisible;

    function addMarkers() {
      viewer.clearOverlays();
      if (!item) item = viewer.world.getItemAt(0);
      if (!item) return;

      for (const m of markers) {
        const imgPt = new OSD.Point(m.x, m.y);
        const vpPt = item.imageToViewportCoordinates(imgPt);
        viewer.addOverlay({
          element: makeMarkerElement(m),
          location: vpPt,
          placement: OSD.Placement.CENTER,
        });
      }
    }

    function setMarkersVisible(v) {
      markersVisible = v;
      if (markersVisible) addMarkers();
      else {
        viewer.clearOverlays();
        hideTip();
      }

      if (toggleBtn) {
        toggleBtn.textContent = markersVisible
          ? "Marker ausblenden"
          : "Marker einblenden";
        toggleBtn.setAttribute(
          "aria-pressed",
          markersVisible ? "true" : "false",
        );
      }
    }

    if (toggleBtn) {
      toggleBtn.addEventListener("click", () =>
        setMarkersVisible(!markersVisible),
      );
      toggleBtn.textContent = markersVisible
        ? "Marker ausblenden"
        : "Marker einblenden";
      toggleBtn.setAttribute("aria-pressed", markersVisible ? "true" : "false");
    }

    // Author mode: Option/Alt + Klick -> Bildkoordinaten anzeigen + kopieren
    let toastTimer = null;

    function showCoords(x, y) {
      if (!toast) return;
      toast.textContent = `x=${x}, y=${y}`;
      toast.style.display = "block";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => (toast.style.display = "none"), 10000);
    }

    async function copy(text) {
      try {
        if (navigator?.clipboard?.writeText)
          await navigator.clipboard.writeText(text);
      } catch (_) {}
    }

    viewer.addHandler("canvas-click", (ev) => {
      if (!authorMode) return;
      const oe = ev?.originalEvent;
      if (!oe?.altKey) return;

      ev.preventDefaultAction = true;
      oe.stopPropagation?.();

      const currentItem = viewer.world.getItemAt(0);
      if (!currentItem) return;

      const webPoint = ev.position;
      const vpPoint = viewer.viewport.pointFromPixel(webPoint);
      const imgPoint = currentItem.viewportToImageCoordinates(vpPoint);

      const x = Math.round(imgPoint.x);
      const y = Math.round(imgPoint.y);

      showCoords(x, y);
      copy(`${x},${y}`);
    });

    function applyStartView() {
      item = viewer.world.getItemAt(0);
      if (!item) return;

      const home = viewer.viewport.getHomeZoom();
      viewer.viewport.minZoomLevel = home;
      viewer.viewport.maxZoomLevel = home * 64;

      if (!startView || startView.type === "home") return;

      if (startView.type === "centerZoom") {
        const imgCenter = new OSD.Point(startView.x, startView.y);
        const vpCenter = item.imageToViewportCoordinates(imgCenter);
        viewer.viewport.panTo(vpCenter, true);
        viewer.viewport.zoomTo(home * startView.zoomFactor, vpCenter, true);
        return;
      }

      if (startView.type === "rect") {
        const r = startView;
        const imgTL = new OSD.Point(r.x, r.y);
        const imgBR = new OSD.Point(r.x + r.w, r.y + r.h);
        const vpTL = item.imageToViewportCoordinates(imgTL);
        const vpBR = item.imageToViewportCoordinates(imgBR);

        const rect = new OSD.Rect(
          vpTL.x,
          vpTL.y,
          vpBR.x - vpTL.x,
          vpBR.y - vpTL.y,
        );
        viewer.viewport.fitBounds(rect, true);

        if (typeof r.zoomFactor === "number") {
          const c = rect.getCenter();
          viewer.viewport.zoomTo(home * r.zoomFactor, c, true);
        }
      }
    }

    function waitAnimationFinish() {
      return new Promise((resolve) => {
        viewer.addOnceHandler("animation-finish", () => resolve());
      });
    }

    function findMarkerById(markerId) {
      return markers.find((m) => m.id === markerId) || null;
    }

    async function flyToWithPinnedTip(detail) {
      if (!detail) return;
      if (detail.mapId !== id) return;

      const markerId = String(detail.id || "");
      const x = Number(detail.x);
      const y = Number(detail.y);
      if (!markerId || !Number.isFinite(x) || !Number.isFinite(y)) return;

      if (!markersVisible) setMarkersVisible(true);

      closePinnedTip();
      hideTip();
      setFrozen(true);

      if (!item) item = viewer.world.getItemAt(0);
      if (!item) {
        setFrozen(false);
        return;
      }

      if (BASE_ZOOM == null) {
        BASE_ZOOM = viewer.viewport.getZoom(true);
        MANUAL_MIN = BASE_ZOOM / 3.0;
        MANUAL_MAX = Math.max(viewer.viewport.maxZoomLevel, BASE_ZOOM * 2.1);
      }

      const zoomOut = BASE_ZOOM / 1.4;
      const zoomIn  = BASE_ZOOM * 2.1;

      // ✅ FlyTo darf die manuellen Grenzen nicht "zudrehen"
      if (MANUAL_MIN != null) viewer.viewport.minZoomLevel = MANUAL_MIN;
      viewer.viewport.maxZoomLevel = Math.max(
        viewer.viewport.maxZoomLevel,
        zoomIn,
        MANUAL_MAX ?? zoomIn
      );

      const imgPt = new OSD.Point(x, y);
      const vpTarget = item.imageToViewportCoordinates(imgPt);

      const oldAnimX = viewer.viewport.centerSpringX.animationTime;
      const oldAnimY = viewer.viewport.centerSpringY.animationTime;
      const oldAnimZ = viewer.viewport.zoomSpring.animationTime;

      viewer.viewport.centerSpringX.animationTime = 1.9;
      viewer.viewport.centerSpringY.animationTime = 1.9;
      viewer.viewport.zoomSpring.animationTime    = 1.9;

      viewer.viewport.zoomTo(zoomOut, undefined, false);
      await waitAnimationFinish();

      viewer.viewport.panTo(vpTarget, false);
      await waitAnimationFinish();

      viewer.viewport.zoomTo(zoomIn, vpTarget, false);
      await waitAnimationFinish();

      viewer.viewport.centerSpringX.animationTime = oldAnimX;
      viewer.viewport.centerSpringY.animationTime = oldAnimY;
      viewer.viewport.zoomSpring.animationTime = oldAnimZ;

      const m = findMarkerById(markerId);
      const title = m?.title || "";
      const subtitle = m?.subtitle || "";
      showPinnedTipAt(title, subtitle, vpTarget, markerId);
    }

    window.addEventListener("dz:flyto", (ev) => {
      try {
        flyToWithPinnedTip(ev.detail);
      } catch (_) {
        closePinnedTip();
        setFrozen(false);
      }
    });

    viewer.addHandler("open", () => {
      applyStartView();
      setMarkersVisible(!!markersDefaultVisible);

      BASE_ZOOM = viewer.viewport.getZoom(true);

      MANUAL_MIN = BASE_ZOOM / 3.0;
      MANUAL_MAX = Math.max(viewer.viewport.maxZoomLevel, BASE_ZOOM * 2.1);

      viewer.viewport.minZoomLevel = MANUAL_MIN;
      viewer.viewport.maxZoomLevel = MANUAL_MAX;
    });
  }
</script>
