---
type Marker = {
  id: string;
  x: number;
  y: number;
  label?: string;
  title?: string;
  subtitle?: string;
  href?: string;
};

type StartView =
  | { type: "home" }
  | { type: "centerZoom"; x: number; y: number; zoomFactor: number }
  | { type: "rect"; x: number; y: number; w: number; h: number; zoomFactor?: number };

const {
  id,
  tileSource,
  markers = [],
  markersDefaultVisible = false,
  showMarkersToggle = true,
  authorMode = true,
  startView = { type: "home" },
  height = 640,
} = Astro.props as {
  id: string;
  tileSource: string | Record<string, any>;
  markers?: Marker[];
  markersDefaultVisible?: boolean;
  showMarkersToggle?: boolean;
  authorMode?: boolean;
  startView?: StartView;
  height?: number;
};

// base-safe URL prefix
// NOTE: robust even if astro.config.mjs base is "/pechgruen-website" (missing trailing slash)
const RAW_BASE = import.meta.env.BASE_URL;
const BASE = RAW_BASE.endsWith("/") ? RAW_BASE : RAW_BASE + "/";
const u = (p: string) => `${BASE}${p.replace(/^\/+/, "")}`;

// ✅ base-safe tileSource for OSD
const tileSourceFixed = typeof tileSource === "string" ? u(tileSource) : tileSource;
---

<div
  id={id}
  style={`
    width:100%;
    height:${height}px;
    background:#000;
    border-radius:12px;
    overflow:hidden;
    position:relative;
  `}
>
  {showMarkersToggle && (
    <button
      type="button"
      data-dz-toggle
      style="
        position:absolute;
        right:6px;
        bottom:6px;
        z-index:10;
        font: inherit;
        padding: 0.35rem 0.6rem;
        border-radius: 10px;
        border: 1px solid rgba(0,0,0,0.25);
        background: rgba(255,255,255,0.85);
        backdrop-filter: blur(4px);
        cursor: pointer;
      "
      aria-pressed={markersDefaultVisible}
    >
      Marker einblenden
    </button>
  )}

  <div
    data-dz-toast
    style="
      position:absolute;
      left:8px;
      bottom:8px;
      z-index:10;
      font: 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      padding: 0.25rem 0.5rem;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.25);
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(4px);
      display:none;
      user-select:text;
      pointer-events:none;
    "
    aria-hidden="true"
  ></div>
</div>

<!-- base-safe vendor path -->
<script is:inline src={u("vendor/openseadragon.min.js")}></script>

<script
  define:vars={{
    id,
    tileSource: tileSourceFixed,
    markers,
    markersDefaultVisible,
    showMarkersToggle,
    authorMode,
    startView
  }}
>
  // @ts-ignore
  const OSD = window.OpenSeadragon;
  const host = document.getElementById(id);

  if (!host || !OSD) {
    console.warn("DeepZoomMap: host or OpenSeadragon missing", { id, host, OSD: !!OSD });
  } else {
    // ✅ Pointer-events-Regel zuverlässig injizieren
    const styleId = `dz-pe-${id}`;
    if (!document.getElementById(styleId)) {
      const s = document.createElement("style");
      s.id = styleId;
      s.textContent = `
        #${id} .openseadragon-overlay,
        #${id} .openseadragon-overlay * {
          pointer-events: auto !important;
        }
      `;
      document.head.appendChild(s);
    }

    const toggleBtn = host.querySelector("[data-dz-toggle]");
    const toast = host.querySelector("[data-dz-toast]");

    const viewer = OSD({
      element: host,
      tileSources: tileSource,
      showNavigationControl: false,
      wrapHorizontal: false,
      wrapVertical: false,
      constrainDuringPan: true,
      visibilityRatio: 1.0,
      zoomPerScroll: 1.02,
      gestureSettingsMouse: {
        scrollToZoom: true,
        clickToZoom: false,
        dblClickToZoom: true,
        pinchToZoom: true,
        flickEnabled: true,
      },
    });

    /* ---------------------------
       Tooltip-Layer (zweizeilig)
       --------------------------- */
    const tip = document.createElement("div");
    tip.id = "marker-tip";
    tip.style.position = "absolute";
    tip.style.zIndex = "20";
    tip.style.pointerEvents = "none";
    tip.style.display = "none";
    tip.style.maxWidth = "360px";
    tip.style.padding = "8px 10px";
    tip.style.borderRadius = "12px";
    tip.style.border = "1px solid rgba(0,0,0,0.25)";
    tip.style.background = "rgba(255,255,255,0.92)";
    tip.style.backdropFilter = "blur(4px)";
    tip.style.boxShadow = "0 8px 22px rgba(0,0,0,0.20)";
    tip.style.font =
      "13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
    tip.style.color = "#111";
    host.appendChild(tip);

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function showTip(title, subtitle, clientX, clientY) {
      const r = host.getBoundingClientRect();
      const t = title || "";
      const s = subtitle || "";

      tip.innerHTML = `
        <div style="font-size:14px; font-weight:600; line-height:1.15;">
          ${escapeHtml(t)}
        </div>
        ${
          s
            ? `<div style="font-size:12px; opacity:0.85; line-height:1.2; margin-top:2px;">
                 ${escapeHtml(s)}
               </div>`
            : ""
        }
      `;

      tip.style.display = "block";

      const pad = 8;
      let x = clientX - r.left + 12;
      let y = clientY - r.top - 12;

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;

      const tr = tip.getBoundingClientRect();
      const maxX = r.width - tr.width - pad;
      const maxY = r.height - tr.height - pad;

      x = Math.max(pad, Math.min(x, maxX));
      y = Math.max(pad, Math.min(y, maxY));

      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function hideTip() {
      tip.style.display = "none";
    }

    /* -----------------------------------------
       Marker: Button statt <a> (keine Statusbar)
       ----------------------------------------- */
    function makeMarkerElement(m) {
      const title = m.title || "";
      const subtitle = m.subtitle || "";
      const aria = subtitle ? `${title} – ${subtitle}` : title;

      const el = document.createElement("button");
      el.type = "button";

      el.style.width = "30px";
      el.style.height = "30px";
      el.style.display = "block";
      el.style.pointerEvents = "auto";
      el.style.touchAction = "manipulation";
      el.style.padding = "0";
      el.style.border = "0";
      el.style.background = "transparent";
      el.style.cursor = m.href ? "pointer" : "default";

      el.setAttribute("aria-label", aria || m.label || "");

      if (title || subtitle) {
        el.addEventListener("pointerenter", (e) =>
          showTip(title, subtitle, e.clientX, e.clientY)
        );
        el.addEventListener("pointermove", (e) =>
          showTip(title, subtitle, e.clientX, e.clientY)
        );
        el.addEventListener("pointerleave", hideTip);
      }

      el.innerHTML = `
        <svg style="pointer-events:none" width="30" height="30" viewBox="0 0 30 30">
          <circle style="pointer-events:none" cx="15" cy="15" r="13" fill="#fff" stroke="#000" stroke-width="1"/>
          <text style="pointer-events:none" x="15" y="15" text-anchor="middle" dominant-baseline="middle"
                dx="-0.03em" dy="0.11em" font-size="12" font-weight="500">${m.label ?? ""}</text>
        </svg>`;

      // OSD darf nicht pannen/zoomen beim Marker-Klick
      const stop = (e) => e.stopPropagation();
      ["pointerdown", "pointerup", "mousedown", "mouseup", "touchstart", "touchend"].forEach((evt) =>
        el.addEventListener(evt, stop, { passive: false })
      );

      if (m.href) {
        const go = (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          hideTip();
          window.location.assign(m.href);
        };

        // capture=true: wir fangen es ab, bevor OSD es verwerten kann
        el.addEventListener("pointerdown", go, true);
        el.addEventListener("click", go, true);
      }

      return el;
    }

    let item = null;
    let markersVisible = !!markersDefaultVisible;

    function addMarkers() {
      viewer.clearOverlays();
      if (!item) item = viewer.world.getItemAt(0);
      if (!item) return;

      for (const m of markers) {
        const imgPt = new OSD.Point(m.x, m.y);
        const vpPt = item.imageToViewportCoordinates(imgPt);
        viewer.addOverlay({
          element: makeMarkerElement(m),
          location: vpPt,
          placement: OSD.Placement.CENTER,
        });
      }
    }

    function setMarkersVisible(v) {
      markersVisible = v;
      if (markersVisible) addMarkers();
      else {
        viewer.clearOverlays();
        hideTip();
      }

      if (toggleBtn) {
        toggleBtn.textContent = markersVisible ? "Marker ausblenden" : "Marker einblenden";
        toggleBtn.setAttribute("aria-pressed", markersVisible ? "true" : "false");
      }
    }

    if (toggleBtn) {
      toggleBtn.addEventListener("click", () => setMarkersVisible(!markersVisible));
      toggleBtn.textContent = markersVisible ? "Marker ausblenden" : "Marker einblenden";
      toggleBtn.setAttribute("aria-pressed", markersVisible ? "true" : "false");
    }

    // Author mode: Option/Alt + Klick -> Bildkoordinaten anzeigen + kopieren
    let toastTimer = null;

    function showCoords(x, y) {
      if (!toast) return;
      toast.textContent = `x=${x}, y=${y}`;
      toast.style.display = "block";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => (toast.style.display = "none"), 10000);
    }

    async function copy(text) {
      try {
        if (navigator?.clipboard?.writeText) await navigator.clipboard.writeText(text);
      } catch (_) {}
    }

    viewer.addHandler("canvas-click", (ev) => {
      if (!authorMode) return;
      const oe = ev?.originalEvent;
      if (!oe?.altKey) return;

      ev.preventDefaultAction = true;
      oe.stopPropagation?.();

      const currentItem = viewer.world.getItemAt(0);
      if (!currentItem) return;

      const webPoint = ev.position;
      const vpPoint = viewer.viewport.pointFromPixel(webPoint);
      const imgPoint = currentItem.viewportToImageCoordinates(vpPoint);

      const x = Math.round(imgPoint.x);
      const y = Math.round(imgPoint.y);

      showCoords(x, y);
      copy(`${x},${y}`);
    });

    function applyStartView() {
      item = viewer.world.getItemAt(0);
      if (!item) return;

      const home = viewer.viewport.getHomeZoom();
      viewer.viewport.minZoomLevel = home;
      viewer.viewport.maxZoomLevel = home * 32;

      if (!startView || startView.type === "home") return;

      if (startView.type === "centerZoom") {
        const imgCenter = new OSD.Point(startView.x, startView.y);
        const vpCenter = item.imageToViewportCoordinates(imgCenter);
        viewer.viewport.panTo(vpCenter, true);
        viewer.viewport.zoomTo(home * startView.zoomFactor, vpCenter, true);
        return;
      }

      if (startView.type === "rect") {
        const r = startView;
        const imgTL = new OSD.Point(r.x, r.y);
        const imgBR = new OSD.Point(r.x + r.w, r.y + r.h);
        const vpTL = item.imageToViewportCoordinates(imgTL);
        const vpBR = item.imageToViewportCoordinates(imgBR);

        const rect = new OSD.Rect(vpTL.x, vpTL.y, vpBR.x - vpTL.x, vpBR.y - vpTL.y);
        viewer.viewport.fitBounds(rect, true);

        if (typeof r.zoomFactor === "number") {
          const c = rect.getCenter();
          viewer.viewport.zoomTo(home * r.zoomFactor, c, true);
        }
      }
    }

    viewer.addHandler("open", () => {
      applyStartView();
      setMarkersVisible(!!markersDefaultVisible);
    });
  }
</script>
